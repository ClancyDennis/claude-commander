// Instruction generation utilities for the instruction wizard
//
// Contains prompt building and response parsing logic for AI-assisted
// instruction draft generation and enhancement.

use super::markdown_parser::extract_json;
use crate::ai_client::ContentBlock;
use serde::{Deserialize, Serialize};

/// Instruction draft generated by AI from user's goal
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct InstructionDraft {
    pub content: String,
    pub suggested_filename: String,
    pub suggested_test_prompt: String,
    pub potential_requirements: Vec<String>,
    pub complexity: String, // "simple", "moderate", "complex"
}

/// Internal type for parsing AI draft response
#[derive(Debug, Deserialize)]
#[serde(rename_all = "camelCase")]
struct AIDraftResponse {
    instruction_content: String,
    suggested_filename: String,
    test_prompt: String,
    potential_requirements: Vec<String>,
    complexity: String,
}

/// Build the system prompt for instruction draft generation.
pub fn build_draft_system_prompt() -> String {
    r#"You are an expert at writing instruction files for AI coding agents like Claude Code.
Your task is to generate a clear, actionable instruction document based on the user's goal.

The instruction should include:
1. A clear title and description
2. Setup steps (authentication, API keys, tool installation if needed)
3. Usage instructions showing how the agent should perform the task
4. Example commands or code patterns
5. Common issues and troubleshooting tips

Focus on:
- Being specific about required credentials, tokens, or API keys
- Including exact commands or steps to set up dependencies
- Providing practical usage examples
- Anticipating common issues and how to resolve them

Respond ONLY with valid JSON matching this schema (no markdown code blocks, just raw JSON):
{
  "instructionContent": "Full markdown instruction content...",
  "suggestedFilename": "descriptive-name.md",
  "testPrompt": "A simple prompt to test this instruction works, e.g. 'List my Google Drive files'",
  "potentialRequirements": ["List of things that may need setup, e.g. 'Google OAuth credentials', 'gh CLI installed'"],
  "complexity": "simple" | "moderate" | "complex"
}"#
    .to_string()
}

/// Build the user prompt for instruction draft generation.
pub fn build_draft_user_prompt(goal: &str, context: Option<&str>) -> String {
    let context_section = context
        .map(|c| format!("\n\nAdditional context provided by the user:\n{}", c))
        .unwrap_or_default();

    format!(
        "Generate an instruction document for the following goal:{}

User's Goal: {}

Remember: Respond with raw JSON only, no markdown formatting.",
        context_section, goal
    )
}

/// Build the system prompt for instruction enhancement.
pub fn build_enhancement_system_prompt() -> String {
    r#"You are an expert at improving instruction files for AI coding agents based on real execution results.

Your task is to take an original instruction draft and a test execution transcript, then produce an ENHANCED version of the instruction that incorporates concrete details learned from the test.

When enhancing, you should:
1. Add specific commands that actually worked during the test
2. Include real file paths, URLs, or endpoints discovered
3. Document any authentication steps or credentials that were needed
4. Add troubleshooting tips based on any errors encountered and resolved
5. Include concrete examples from the successful execution
6. Update vague instructions with specific, tested steps
7. Add environment setup details that were discovered (env vars, configs, etc.)

Important guidelines:
- Keep the original structure and sections
- Don't remove information, only add or clarify
- Use the actual command outputs to make instructions more concrete
- If the test revealed missing prerequisites, add them
- If certain steps failed and were fixed, document the fix

Output ONLY the enhanced markdown instruction content. Do not include any explanation or wrapper - just the improved instruction document."#
        .to_string()
}

/// Build the user prompt for instruction enhancement.
pub fn build_enhancement_user_prompt(original: &str, transcript: &str) -> String {
    // Truncate transcript if too long (keep last part which usually has most relevant info)
    let max_transcript_len = 15000;
    let truncated_transcript = if transcript.len() > max_transcript_len {
        format!(
            "[... earlier output truncated ...]\n\n{}",
            &transcript[transcript.len() - max_transcript_len..]
        )
    } else {
        transcript.to_string()
    };

    format!(
        r#"## Original Instruction

{}

## Test Execution Transcript

{}

---

Please enhance the original instruction based on what was learned during the test execution. Output only the improved markdown content."#,
        original, truncated_transcript
    )
}

/// Build a smart test instruction that includes setup verification.
///
/// This wraps the user's instruction with additional phases for:
/// - Verifying requirements are properly configured
/// - Helping set up missing requirements
/// - Testing the actual instruction end-to-end
pub fn build_smart_test_instruction(user_instruction: &str, requirements: &[String]) -> String {
    let requirements_section = if requirements.is_empty() {
        "No specific requirements were identified. Proceed directly to testing the instruction."
            .to_string()
    } else {
        let req_list = requirements
            .iter()
            .enumerate()
            .map(|(i, r)| format!("{}. {}", i + 1, r))
            .collect::<Vec<_>>()
            .join("\n");
        format!(
            r#"Before testing, verify these requirements are properly configured:

{}

For each requirement:
1. Check if it's already set up (test it!)
2. If not configured, clearly explain what's needed and help the user set it up
3. Verify the configuration works before proceeding
4. Only move on once the requirement is confirmed working"#,
            req_list
        )
    };

    format!(
        r#"# Smart Test Agent

You are testing an instruction file to verify it works and help configure any missing requirements.

## Phase 1: Setup Verification

{requirements_section}

## Phase 2: Test the Instruction

Once all requirements are verified (or if there were none), test this instruction:

---

{user_instruction}

---

## Your Guidelines

- **Be proactive**: Check each requirement before the user asks
- **Be helpful**: If something is missing, explain exactly how to set it up
- **Verify everything**: After configuring something, test that it actually works
- **Report clearly**: Tell the user what's working and what needs attention
- **Don't skip steps**: If auth is needed, help set it up before trying the main task
- **Continue testing**: Once setup is complete, actually run through the instruction to verify it works end-to-end

Start by checking the requirements (if any), then proceed to test the instruction."#,
        requirements_section = requirements_section,
        user_instruction = user_instruction
    )
}

/// Parse the AI response into an InstructionDraft.
pub fn parse_draft_response(content: &[ContentBlock]) -> Result<InstructionDraft, String> {
    // Extract text content from response
    let text = content
        .iter()
        .filter_map(|block| {
            if let ContentBlock::Text { text } = block {
                Some(text.as_str())
            } else {
                None
            }
        })
        .collect::<Vec<_>>()
        .join("");

    // Try to parse JSON from the response
    let json_str = extract_json(&text);

    let ai_response: AIDraftResponse = serde_json::from_str(json_str.trim()).map_err(|e| {
        format!(
            "Failed to parse AI response as JSON: {}. Response was: {}",
            e,
            &text[..text.len().min(500)]
        )
    })?;

    Ok(InstructionDraft {
        content: ai_response.instruction_content,
        suggested_filename: ai_response.suggested_filename,
        suggested_test_prompt: ai_response.test_prompt,
        potential_requirements: ai_response.potential_requirements,
        complexity: ai_response.complexity,
    })
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_build_draft_system_prompt() {
        let prompt = build_draft_system_prompt();
        assert!(prompt.contains("instruction files"));
        assert!(prompt.contains("JSON"));
    }

    #[test]
    fn test_build_draft_user_prompt_without_context() {
        let prompt = build_draft_user_prompt("Create a CLI tool", None);
        assert!(prompt.contains("Create a CLI tool"));
        assert!(!prompt.contains("Additional context"));
    }

    #[test]
    fn test_build_draft_user_prompt_with_context() {
        let prompt = build_draft_user_prompt("Create a CLI tool", Some("Use Rust"));
        assert!(prompt.contains("Create a CLI tool"));
        assert!(prompt.contains("Use Rust"));
        assert!(prompt.contains("Additional context"));
    }

    #[test]
    fn test_build_smart_test_instruction_without_requirements() {
        let result = build_smart_test_instruction("Test instruction", &[]);
        assert!(result.contains("No specific requirements"));
        assert!(result.contains("Test instruction"));
    }

    #[test]
    fn test_build_smart_test_instruction_with_requirements() {
        let requirements = vec!["API key".to_string(), "Node.js installed".to_string()];
        let result = build_smart_test_instruction("Test instruction", &requirements);
        assert!(result.contains("1. API key"));
        assert!(result.contains("2. Node.js installed"));
        assert!(result.contains("Test instruction"));
    }

    #[test]
    fn test_build_enhancement_user_prompt_truncates_long_transcript() {
        let original = "Short original";
        let long_transcript = "x".repeat(20000);
        let result = build_enhancement_user_prompt(original, &long_transcript);
        assert!(result.contains("[... earlier output truncated ...]"));
        assert!(result.len() < long_transcript.len() + 1000);
    }

    #[test]
    fn test_parse_draft_response_valid() {
        let json_text = r##"{"instructionContent": "# Test", "suggestedFilename": "test.md", "testPrompt": "Run test", "potentialRequirements": ["req1"], "complexity": "simple"}"##;
        let content = vec![ContentBlock::Text {
            text: json_text.to_string(),
        }];
        let result = parse_draft_response(&content);
        assert!(result.is_ok());
        let draft = result.unwrap();
        assert_eq!(draft.content, "# Test");
        assert_eq!(draft.suggested_filename, "test.md");
    }

    #[test]
    fn test_parse_draft_response_invalid_json() {
        let content = vec![ContentBlock::Text {
            text: "Not valid JSON".to_string(),
        }];
        let result = parse_draft_response(&content);
        assert!(result.is_err());
    }
}
